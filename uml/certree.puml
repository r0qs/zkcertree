@startuml (id=Registration)
' == Registration Phase ==
Subject -> Issuer: <latex>Enrollment(PK_{s})</latex>
' Creates a credential as a precise proof (merkle tree) for the subject s
Issuer -> Issuer: <latex>Root_{ct}, CredDocument_{s} = CreateCredential(s, data)</latex>
' Send the credential to the subject over an encrypted channel
Issuer -[#FF0000]> Subject: <latex>CredDocument_{s}</latex><size:28><&lock-locked></size>
' Subject -> Subject: <latex>CheckCredClaims()</latex>
group Issue Circuit
  ' Subject -> Subject: <latex>nullifier = Root_{ct}</latex>
  ' In our case the nullifier is a shared data between the issuer and the subject
  ' TODO: Alternativaly we could hide the nullifier from the issuer while still able to prove
  ' the correcness of the commitment (e.g. h(CRoot + salt)).
  Subject -> Subject: <latex>Comm = h(Root_{ct}, secret, h(PK_{s}))</latex>
  Subject -> Subject: <latex>proof_{zk} = zkProof(Comm, Sign(SK_{s}, Comm))</latex>
end
Subject -[#FF0000]> Issuer : <latex>(proof_{zk}, Comm)</latex><size:28><&lock-locked></size>
note right Issuer
  Checks:
    - The commitment is from the correct credential root
    - The commitment is signed by the correct subject
end note
Issuer -> Issuer: <latex>Verify(proof_{zk}, Comm, Root_{ct}, PK_{s})</latex>
Issuer -> Contract: <latex>Issue(Comm)</latex>

Contract -> Contract: <latex>mt.Insert(Comm)</latex>
Contract -> Contract: <latex>Event:CredentialCreated(Comm, index, timestamp)</latex>
@enduml

@startuml (id=Approval)
' == Approval Phase ==
Subject -> Contract: <latex>CollectCredentialCreatedEvents()</latex>
Contract --> Subject: <latex>events</latex>
Subject -> Subject: <latex>mt = BuildCertTree(events)</latex>
Subject -> Subject: <latex>ct = BuildCredTree(credDocument)</latex>
group Approve Circuit
  Subject -> Subject: <latex>Comm = h(Root_{ct}, secret, h(PK_{s}))</latex>
  Subject -> Subject: <latex>proof_{mt} = MerkleProof(Root_{mt}, Comm)</latex>
  Subject -> Subject: <latex>proof_{zk} = zkProof(Comm, proof_{mt}, sender)</latex>
end
Subject -> Contract: <latex>Approve(proof_{zk}, Root_{mt}, h(Root_{ct}))</latex>
' Attest subject consents with the credential's claims
note right Contract
  Checks:
    - The commitment exists in the contract's merkle tree
    - The credential was not approved already
    - The sender is the creator of the proof
end note
Contract -> Contract: <latex>Verify(proof_{zk}, Root_{mt}, h(Root_{ct}), sender)</latex>
Contract -> Contract: <latex>MarkCredentialAsIssued(h(Root_{ct}))</latex>
Contract -> Contract: <latex>Event:CredentialIssued(sender, h(Root_{ct}), timestamp)</latex>
@enduml

@startuml (id=Revocation)
' == Revocation ==
Issuer -> Contract: <latex>Revoke(h(Root_{ct}), reason)</latex>
Contract -> Contract: <latex>MarkCredentialAsRevoked(h(Root_{ct}))</latex>
Contract -> Contract: <latex>Event:CredentialRevoked(h(Root_{ct}), reason, timestamp)</latex>
@enduml

@startuml (id=PresentationAuth)
' == Presentation: Authenticity Check ==
Verifier -> Subject: <latex>RequestAuthProof()</latex>
Subject -> Contract: <latex>CollectCredentialCreatedEvents()</latex>
Contract --> Subject: <latex>events</latex>
Subject -> Subject: <latex>mt = BuildCertTree(events)</latex>
Subject -> Subject: <latex>ct = BuildCredTree(credDocument)</latex>
group PresentationAuth Circuit
  Subject -> Subject: <latex>Comm = h(Root_{ct}, secret, h(PK_{s}))</latex>
  Subject -> Subject: <latex>proof_{mt} = MerkleProof(Root_{mt}, Comm)</latex>
  Subject -> Subject: <latex>proof_{zk} = zkProof(Comm, proof_{mt}, Sign(SK_{s}, Comm))</latex>
end
Subject -> Verifier: <latex>(proof_{zk}, h(Root_{ct}),  Root_{mt}, PK_{s})</latex>
Verifier -> Contract: <latex>IsKnownRoot(Root_{mt})</latex>
Contract --> Verifier: <latex>true/false</latex>
note right Verifier
  Checks:
    - The subject knows the pre-image of a commitment for the presented credential
    - The credential was issued to him (he has knowledge of the EdDSA private key)
    - The subject consent with the claims in the credential (i.e. signed by the subject)
    - The commitment exists in the contract's merkle tree for the given root (was created by the right issuer => require ENS check!)
    - The credential was not revoked or expired
end note
Verifier -> Contract: <latex>VerifyCredentialStatus(h(Root_{ct}))</latex>
alt #lightgreen Successful case
  Contract --> Verifier: Credential is valid (not revoked or expired)
else #pink Failure
  Contract --> Verifier: Credential is not valid
end
Verifier -> Verifier: <latex>Verify(proof_{zk}, h(Root_{ct}), Root_{mt}, PK_{s})</latex>
@enduml

@startuml (id=PresentationConditionalQuery)
' == Presentation: Credential's Conditional Check ==
' TODO: retrieve credtree schema
Verifier -> Subject: <latex>RequestProofFor(FieldKey, Criterion, OP)</latex>
Subject -> Contract: <latex>CollectCredentialCreatedEvents()</latex>
Contract --> Subject: <latex>events</latex>
Subject -> Subject: <latex>mt = BuildCertTree(events)</latex>
Subject -> Subject: <latex>ct = BuildCredTree(credDocument)</latex>
group QueryCredentialField Circuit
  Subject -> Subject: <latex>Comm = h(Root_{ct}, secret, h(PK_{s}))</latex>
  Subject -> Subject: <latex>proof_{mt} = MerkleProof(Root_{mt}, Comm)</latex>
  Subject -> Subject: <latex>field = h(FieldKey, value, salt)</latex>
  Subject -> Subject: <latex>proof_{ct} = MerkleProof(Root_{ct}, field)</latex>
  Subject -> Subject: <latex>proof_{zk} = zkProof(proof_{mt}, proof_{ct}, FieldKey, Criterion, OP) == 1</latex>
end
Subject -> Verifier: <latex>(proof_{zk}, h(Root_{ct}),  Root_{mt})</latex>
Verifier -> Contract: <latex>IsKnownRoot(Root_{mt})</latex>
Contract --> Verifier: <latex>true/false</latex>
Verifier -> Contract: <latex>VerifyCredentialStatus(h(Root_{ct}))</latex>
alt #lightgreen Successful case
  Contract --> Verifier: Credential is valid (not revoked or expired)
else #pink Failure
  Contract --> Verifier: Credential is not valid
end
Verifier -> Verifier: <latex>Verify(proof_{zk}, h(Root_{ct}), Root_{mt}, FieldKey, Criterion, OP)</latex>
@enduml

@enduml